// File: fluent_grammar.lark
// Grammar definition for the Fluent language

?start: statement*

// Statements
?statement: variable_declaration | assignment | print_statement | function_call_statement
          | if_statement | while_statement | foreach_statement
          | function_definition | return_statement | break_statement 
          | COMMENT -> ignored_statement

variable_declaration: "VAR" IDENTIFIER "AS" type ["=" expression] _TERMINATOR
assignment: IDENTIFIER "=" expression _TERMINATOR
print_statement: "PRINT" expression _TERMINATOR
function_call_statement: function_call _TERMINATOR
return_statement: "RETURN" [expression] _TERMINATOR
break_statement: "BREAK" _TERMINATOR

// Control Flow
if_statement: "IF" expression "THEN" _TERMINATOR statement* ["ELSE" _TERMINATOR statement*] "ENDIF" _TERMINATOR?
while_statement: "WHILE" expression _TERMINATOR statement* "ENDWHILE" _TERMINATOR?
foreach_statement: "FOREACH" IDENTIFIER "IN" expression _TERMINATOR statement* "ENDFOREACH" _TERMINATOR?

// Function Definition
function_definition: "FUNCTION" IDENTIFIER "(" [parameters] ")" ["RETURNS" type] _TERMINATOR statement* "ENDFUNCTION" _TERMINATOR?
parameters: parameter ("," parameter)*
parameter: "PARAM" IDENTIFIER "AS" type

// Types
?type: basetype | list_type | map_type
basetype: "INTEGER" | "FLOAT" | "STRING" | "BOOLEAN" | "NULLTYPE"
list_type: "LIST" "<" type ">"
map_type: "MAP" "<" type "," type ">"

// --- Expressions with explicit precedence ---
?expression: logical_or

?logical_or: logical_and ("OR" logical_and)*       // Lowest precedence
?logical_and: comparison ("AND" comparison)*
?comparison: arith_expr [comp_op arith_expr]
comp_op: "==" | "!=" | "<" | "<=" | ">" | ">="
?arith_expr: term (("+" | "-") term)*
?term: factor (("*" | "/") factor)*             
?factor: unary_op factor | atom       // Unary operators bind tightest
unary_op: "+" | "-" | "NOT"

?atom: NUMBER | FLOAT_NUMBER | STRING_LITERAL | BOOLEAN_LITERAL | NULL_LITERAL
     | IDENTIFIER
     | list_literal | map_literal 
     | function_call
     | "(" expression ")"

// Literals
NUMBER: SIGNED_INT
FLOAT_NUMBER: SIGNED_FLOAT
STRING_LITERAL: ESCAPED_STRING
BOOLEAN_LITERAL: "TRUE" | "FALSE"
NULL_LITERAL: "NULL"

// List/Map Literals
list_literal: "[" [expression ("," expression)*] "]"
map_literal: "{" [map_entry ("," map_entry)*] "}"
map_entry: expression ":" expression

// Function Calls
function_call: "CALL" IDENTIFIER "(" [arguments] ")"
arguments: expression ("," expression)*

// Terminals
IDENTIFIER: CNAME
COMMENT: "//" /[^\n]*/
_TERMINATOR: ";" | _NL 

%import common.SIGNED_INT
%import common.SIGNED_FLOAT
%import common.ESCAPED_STRING
%import common.CNAME
%import common.WS_INLINE
%import common.NEWLINE -> _NL

%ignore WS_INLINE
%ignore COMMENT
%ignore _NL+ // Ignore blank lines between statements
